# Koine grammar for the SLIP language v2
# Rewritten to ensure correct, flat AST structures.

start_rule: program

rules:

  # =================================================================
  # Top Level & Whitespace
  # =================================================================

  program_padding:
    ast: { discard: true }
    zero_or_more:
      choice:
        - { regex: '\s+' }
        - { rule: comment }

  program:
    ast: { tag: "code" }
    sequence:
      - { rule: program_padding }
      - { rule: expression_list }
      - { rule: program_padding }

  expression_list:
    ast: { promote: true }
    choice:
      - sequence: # one or more expressions
          - { rule: line_expression }
          - zero_or_more:
              ast: { promote: true }
              sequence:
                - { rule: expression_separator_plus }
                - { rule: line_expression }
          - optional: { rule: expression_separator_plus }
      - { rule: empty_list_producer }

  empty_list_producer:
    ast: { promote: true }
    zero_or_more:
      { regex: "(?!)" }

  expression_separator:
    ast: { discard: true }
    choice:
      - { literal: ";" }
      - { literal: "," }
      - { rule: NEWLINE }

  expression_separator_plus:
    ast: { discard: true }
    sequence:
      - { rule: WS_OPT }
      - one_or_more:
          sequence:
            - { rule: expression_separator }
            - { rule: WS_OPT }

  NEWLINE:
    ast: { discard: true }
    regex: '[\r\n]+'

  line_expression:
    # Order is crucial: colon_expr is more specific.
    ast: { tag: "expr" }
    choice:
      - { rule: colon_expr }
      - { rule: expression_content }

  expression_content:
    ast: { promote: true }
    sequence:
      - { rule: term }
      - zero_or_more:
          ast: { promote: true }
          sequence:
            - { rule: WS_OPT }
            - { rule: term }

  WS_OPT: # Optional whitespace (includes comments)
    ast: { discard: true }
    zero_or_more:
      choice:
        - { regex: '[ \t]+' }
        - { rule: comment }


  comment:
    ast: { discard: true }
    choice:
      - { rule: line_comment }
      - { rule: block_comment }

  line_comment:
    sequence:
      - { literal: "//" }
      - positive_lookahead:
          choice:
            - { regex: '\s' } # whitespace or newline
            - { regex: '$' }  # end of input
      - { regex: '[^\r\n]*' }

  block_comment:
    sequence:
      - { literal: "/*" }
      - zero_or_more:
          choice:
            - { rule: block_comment }
            - { regex: '((?!/\*|\*/).)+' }
      - { literal: "*/" }

  # =================================================================
  # Expressions (Flat List Parsing)
  # =================================================================

  term:
    ast: { promote: true }
    choice:
      # Specific container literals must come before general rules like `path`
      - { rule: list_literal }
      - { rule: env_literal }
      - { rule: dict_literal }
      - { rule: code_block }
      - { rule: group } # Must come before path to resolve ambiguity with dynamic segments
      - { rule: literal }
      - { rule: path }

  # =================================================================
  # Assignment / Colon Expression
  # =================================================================

  colon_expr:
    ast: { promote: true }
    sequence:
      - { rule: assignment_target }
      - { rule: WS_OPT }
      - { literal: ":", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: expression_content }

  assignment_target:
    ast: { promote: true }
    choice:
      # Order is crucial: a group can be a dynamic target and must not be parsed as a set_path
      - { rule: multi_set }
      - { rule: group }
      - { rule: set_path }

  multi_set:
    ast: { tag: "multi-set" }
    sequence:
      - { literal: "[", ast: { discard: true } }
      - { rule: WS_OPT }
      - optional:
          sequence:
            - { rule: set_path }
            - zero_or_more:
                ast: { promote: true }
                sequence:
                  - { rule: expression_separator_plus }
                  - { rule: set_path }
      - { rule: WS_OPT }
      - { literal: "]", ast: { discard: true } }


  # =================================================================
  # Literals
  # =================================================================

  literal:
    ast: { promote: true }
    # Order: more specific keywords first
    choice:
      - { rule: boolean_literal }
      - { rule: none_literal }
      - { rule: number_literal }
      - { rule: string_literal }
      - { rule: path_literal }

  number_literal:
    ast: { tag: "number", leaf: true, type: "number" }
    regex: '-?\d+(\.\d+)?'

  string_literal:
    ast: { promote: true }
    choice:
      - { rule: raw_string }
      - { rule: interpolated_string }

  raw_string:
    ast: { promote: true }
    sequence:
      - { literal: "'", ast: { discard: true } }
      - { rule: raw_string_content }
      - { literal: "'", ast: { discard: true } }
  raw_string_content:
    ast: { tag: "string", leaf: true }
    regex: "([^'\\\\]|\\\\.)*"

  interpolated_string:
    ast: { promote: true }
    sequence:
      - { literal: '"', ast: { discard: true } }
      - { rule: interpolated_string_content }
      - { literal: '"', ast: { discard: true } }
  interpolated_string_content:
    ast: { tag: "i-string", leaf: true }
    regex: '([^"\\]|\\.)*'

  boolean_literal:
    ast: { tag: "boolean", leaf: true, type: "bool" }
    choice:
      - { literal: "true" }
      - { literal: "false" }

  none_literal:
    ast: { tag: "null", leaf: true, type: "null" }
    literal: "none"

  path_literal:
    ast: { tag: "path-literal" }
    sequence:
      - { literal: "`", ast: { discard: true } }
      - { rule: path_base }
      - { literal: "`", ast: { discard: true } }

  # =================================================================
  # Paths
  # =================================================================

  path_base_no_prefix:
    ast: { promote: true }
    sequence:
      - { rule: path_segment_no_prefix }
      - zero_or_more:
          ast: { promote: true }
          choice:
            - { rule: dotted_path_segment }
            - { rule: path_segment_suffix }

  path:
    ast: { tag: "path" }
    sequence:
      - optional: { rule: pipe_segment }
      - { rule: path_base }

  set_path:
    ast: { tag: "set-path" }
    rule: set_path_content

  set_path_content:
    ast: { promote: true }
    choice:
      - sequence:
          - choice:
              - { rule: root_segment }
              - { rule: parent_segment }
              - { rule: pwd_segment }
          - { rule: set_path_content }
      - { rule: path_base_no_prefix }

  pipe_segment:
    ast: { promote: true }
    sequence:
      - { literal: "|", ast: { tag: "pipe" } }
      - { rule: WS_OPT }

  path_base:
    ast: { promote: true }
    choice:
      - sequence:
          - choice:
              - { rule: root_segment }
              - { rule: parent_segment }
              - { rule: pwd_segment }
          - { rule: path_base }
      - { rule: path_base_no_prefix }

  dotted_path_segment:
    ast: { promote: true }
    sequence:
      - { rule: WS_OPT }
      - { literal: ".", ast: { discard: true } }
      - { rule: WS_OPT }
      - choice:
          - { rule: path_segment_no_prefix }
          - { rule: dynamic_segment }

  path_segment_no_prefix:
    ast: { promote: true }
    choice:
      # Segments that don't have a special prefix like `/` or `../`
      - { rule: operator_path }
      - { rule: name_path }

  path_segment_suffix:
    ast: { promote: true }
    choice:
      # Segments that can only appear after an initial segment
      # Slice must come first to disambiguate from index
      - { rule: slice_segment }
      - { rule: index_segment }

  root_segment:
    ast: { tag: "root", leaf: true }
    sequence:
      - { literal: "/" }
      # A root must be followed by another segment to distinguish it from the '/' operator
      - positive_lookahead:
          { rule: path_segment_no_prefix }
  parent_segment: { ast: { tag: "parent", leaf: true }, literal: "../" }
  pwd_segment: { ast: { tag: "pwd", leaf: true }, literal: "./" }

  operator_path:
    ast: { tag: "name", leaf: true }
    choice:
      - { regex: '[!@#$%^&*-+]+' }
      - { literal: "/" }

  name_path:
    ast: { tag: "name", leaf: true }
    choice:
      - { regex: '[a-zA-Z0-9-]+\.\.\.' }
      - { regex: '[a-zA-Z0-9-]+' }

  dynamic_segment: { ast: { promote: true }, rule: group }

  bracketed_expression:
    ast: { tag: "expr" }
    rule: expression_content

  index_segment:
    ast: { tag: "index" }
    sequence:
      - { literal: "[", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: bracketed_expression }
      - { rule: WS_OPT }
      - { literal: "]", ast: { discard: true } }

  slice_segment:
    ast: { tag: "slice" }
    sequence:
      - { literal: "[", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: slice_content }
      - { rule: WS_OPT }
      - { literal: "]", ast: { discard: true } }

  slice_content:
    ast: { promote: true }
    sequence:
      - optional: { rule: bracketed_expression }
      - { literal: ":", ast: { discard: true } }
      - optional: { rule: bracketed_expression }

  # =================================================================
  # Grouping & Container Literals
  # =================================================================

  list_line_expression:
    # Same as line_expression, but without `ast: { tag: "expr" }` so that
    # list items are not wrapped in an extra `expr` node.
    ast: { promote: true }
    choice:
      - { rule: colon_expr }
      - { rule: expression_content }

  list_expression_list:
    ast: { promote: true }
    choice:
      - sequence: # one or more expressions
          - { rule: list_line_expression }
          - zero_or_more:
              ast: { promote: true }
              sequence:
                - { rule: expression_separator_plus }
                - { rule: list_line_expression }
          - optional: { rule: expression_separator_plus }
      - { rule: empty_list_producer }

  group_line_expression:
    # Same as line_expression, but without `ast: { tag: "expr" }` so that
    # group items are not wrapped in an extra `expr` node.
    ast: { promote: true }
    choice:
      - { rule: colon_expr }
      - { rule: expression_content }

  group_expression_list:
    ast: { promote: true }
    choice:
      - sequence: # one or more expressions
          - { rule: group_line_expression }
          - zero_or_more:
              ast: { promote: true }
              sequence:
                - { rule: expression_separator_plus }
                - { rule: group_line_expression }
          - optional: { rule: expression_separator_plus }
      - { rule: empty_list_producer }

  group:
    ast: { tag: "expr" }
    sequence:
      - { literal: "(", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: group_expression_list }
      - { rule: WS_OPT }
      - { literal: ")", ast: { discard: true } }

  code_block:
    ast: { tag: "code" }
    sequence:
      - { literal: "[", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: expression_list }
      - { rule: WS_OPT }
      - { literal: "]", ast: { discard: true } }

  list_literal:
    ast: { tag: "list" }
    sequence:
      - { literal: "#[", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: list_expression_list }
      - { rule: WS_OPT }
      - { literal: "]", ast: { discard: true } }

  dict_literal:
    ast: { tag: "dict" }
    sequence:
      - { literal: "{", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: expression_list }
      - { rule: WS_OPT }
      - { literal: "}", ast: { discard: true } }

  env_literal:
    ast: { tag: "env" }
    sequence:
      - { literal: "#{", ast: { discard: true } }
      - { rule: WS_OPT }
      - { rule: expression_list }
      - { rule: WS_OPT }
      - { literal: "}", ast: { discard: true } }
