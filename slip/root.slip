{--
    SLIP Core Library v1.0

    This library provides a set of common, high-level utilities
    written in pure SLIP. It is loaded into the global scope.
    Note: this file is loaded directly into the root scope, so all
    definitions are global.
--}

-- --- Operator and Alias Definitions ---
-- Note: The core functions (add, sub, etc.) are host primitives.
-- These bindings make them available as infix operators.
+: |core-add
-: |core-sub
*: |core-mul
/: |core-div
**: |core-pow
=: |core-eq
!=: |core-neq
>: |core-gt
>=: |core-gte
<: |core-lt
<=: |core-lte
and: |logical-and
or: |logical-or

-- Common aliases for response statuses
ok:        `ok`
err:       `err`
not-found: `not-found`
invalid:   `invalid`

-- (No type aliases; refer to types via backticked path literals like `string`, `number`, `list`)

-- Common aliases
print: fn {msg} [ emit "stdout" msg ]
stderr: fn {msg} [ emit "stderr" msg ]

-- --- Type Utilities ---
-- Note: `type-of` is a host primitive.
is-number?:  fn {x} [ logical-or (eq (type-of x) `int`) (eq (type-of x) `float`) ]
is-string?:  fn {x} [ logical-or (eq (type-of x) `string`) (eq (type-of x) `i-string`) ]
is-list?:    fn {x} [ eq (type-of x) `list` ]
is-dict?:    fn {x} [ eq (type-of x) `dict` ]
is-scope?:   fn {x} [ eq (type-of x) `scope` ]
is-path?:    fn {x} [ eq (type-of x) `path` ]
is-fn?:      fn {x} [ eq (type-of x) `function` ]
is-code?:    fn {x} [ eq (type-of x) `code` ]
is-boolean?: fn {x} [ eq (type-of x) `boolean` ]
is-none?:    fn {x} [ eq (type-of x) `none` ]

-- --- String and Path Utilities ---
-- Provide a generic 'join' with typed methods for strings and paths.
-- String variant: join a list of strings with a separator.
join: fn {xs: `list`, sep: `string`} [
    (call str-join #[ xs, sep ])
]

-- Path variant: join path segments/values into a single path literal.
join: fn {first: `path`, rest...} [
    args: add #[ first ] rest
    (call join-paths args)
]


-- String variant (delegates to primitive)
replace: fn {s: `string`, old: `string`, new: `string`} [
  str-replace s old new
]

-- Unions: ordered sequence-like and mapping-like
ordered: { code or list or dict or scope }
mapping: { dict or scope }
number: { int or float }

-- List-like variant: replace items equal to old[0] with new[0] (works for Code and List)
replace: fn {src: `ordered`, old: `ordered`, new: `ordered`} [
  out: clone src
  i: 0
  while [i < (len out)] [
    if [eq out[i] old[0]] [
      out[i]: new[0]
    ]
    i: i + 1
  ]
  out
]

-- --- List & Sequence Utilities ---

-- Reverses a list by iterating through it and prepending
-- each item to a new list.
reverse: fn {data-list: `ordered`} [
    result: #[]
    -- For each item in the original list (from start to end)...
    foreach {item} data-list [
        -- ...prepend it to the front of our result list.
        result: add #[ item ] result
    ]
    return result
]

-- Applies a function to each item in a list and returns a new
-- list containing the results.
map: fn {func, data-list: `ordered`} [
    results: #[]
    foreach {item} data-list [
        results: add results #[ (func item) ]
    ]
    return results
]

-- Data-first overload to support pipe style: list |map (fn {...})
map: fn {data-list: `ordered`, func: `function`} [
    results: #[]
    foreach {item} data-list [
        results: add results #[ (func item) ]
    ]
    return results
]

-- Filters a list, returning a new list containing only the items
-- for which the predicate function returns a truthy value.
filter: fn {predicate, data-list: `ordered`} [
    results: #[]
    foreach {item} data-list [
        if [predicate item] [
            results: add results #[ item ]
        ]
    ]
    return results
]

-- Data-first overload to support pipe style: list |filter (fn {...})
filter: fn {data-list: `ordered`, predicate: `function`} [
    results: #[]
    foreach {item} data-list [
        if [predicate item] [
            results: add results #[ item ]
        ]
    ]
    return results
]

-- Reduces a list to a single value by applying a function cumulatively.
reduce: fn {reducer, accumulator, data-list: `ordered`} [
    foreach {item} data-list [
        accumulator: reducer accumulator item
    ]
    return accumulator
]

-- Combines two lists into a list of pairs. The resulting list's
-- length is determined by the shorter of the two input lists.
zip: fn {list-a: `ordered`, list-b: `ordered`} [
    results: #[]
    limit: if [(len list-a) < (len list-b)] [len list-a] [len list-b]
    i: 0
    while [i < limit] [
        results: add results #[ #[ list-a[i], list-b[i] ] ]
        i: i + 1
    ]
    return results
]

-- --- Function Utilities ---

-- Creates a new function that, when called, will invoke the original
-- function with the pre-supplied arguments, followed by any new arguments.
partial: fn {func, partial-args...} [
    return (fn {new-args...} [
        -- `add` creates a new list by concatenating the pre-supplied
        -- arguments with any new arguments.
        all-args: add partial-args new-args
        return (call func all-args)
    ])
]

-- Composes functions, returning a new function that applies them from
-- right to left. (compose f g h)(x) is equivalent to f(g(h(x))).
compose: fn {funcs...} [
    return (fn {initial-arg} [
        result: initial-arg
        foreach {f} (reverse funcs) [
            result: (call f #[ result ])
        ]
        result
    ])
]


-- --- Object Model Utilities ---

-- The base object for all validation schemas.
Schema: scope #{}

-- The canonical way to create a validation schema.
schema: fn {config} [
    (scope config) |inherit Schema
]

-- Checks if an object inherits from a given prototype.
is-a?: fn {obj, proto} [
    -- We can only check scopes.
    if [not (is-scope? obj)] [
        return false
    ]
    current: obj
    while [current] [
        if [eq current proto] [
            return true
        ]
        -- Walk up the prototype chain.
        current: current.meta.parent
    ]
    return false
]

-- Checks if an object is a schema.
is-schema?: fn {obj} [
    is-a? obj Schema
]

-- Marker constructors for schemas
default: fn {value} [
  #{
    __marker__: `default`,
    value: value
  }
]

optional: fn {type} [
  #{
    __marker__: `optional`,
    type: type
  }
]

-- Helpers for validation
has-key?: fn {m: `mapping`, key} [
  probe: do [ m[key] ]
  if [probe.outcome.status = ok] [ true ] [ false ]
]

is-default-marker?: fn {x} [
  logical-and (is-dict? x) (logical-and (has-key? x "__marker__") (eq x["__marker__"] `default`))
]

is-optional-marker?: fn {x} [
  logical-and (is-dict? x) (logical-and (has-key? x "__marker__") (eq x["__marker__"] `optional`))
]

type-name-from-type: fn {ptype: `path`} [
  ptype.inner.segments[0].text
]

value-type-name: fn {v} [
  (type-name-from-type (type-of v))
]

collect-schema-fields: fn {sch: `scope`} [
  chain: #[]
  cur: sch
  while [cur] [
    chain: add #[cur] chain
    cur: cur.meta.parent
  ]
  chain: reverse chain
  fields: #{}
  foreach {s} chain [
    foreach {k, v} (items s) [
      fields[k]: v
    ]
  ]
  fields
]

-- Validate data against a schema, applying defaults and honoring optional fields.
validate: fn {data: `mapping`, sch: `scope`} [
  fields: collect-schema-fields sch
  out: #{}
  errs: #[]
  foreach {k, spec} (items fields) [
    present: has-key? data k
    if [present] [
      v: data[k]
      if [is-optional-marker? spec] [
        t: spec["type"]
        if [is-schema? t] [
          res: validate v t
          if [eq res.status ok] [ out[k]: res.value ] [
            errs: add errs res.value
          ]
        ] [
          if [is-path? t] [
            if [eq (type-of v) t] [ out[k]: v ] [
              errs: add errs #[ #{ field: k, error: i"expected type '{type-name-from-type t}', got '{value-type-name v}'" } ]
            ]
          ] [
            out[k]: v
          ]
        ]
      ] [
        if [is-default-marker? spec] [
          out[k]: v
        ] [
          if [is-schema? spec] [
            res: validate v spec
            if [eq res.status ok] [ out[k]: res.value ] [
              errs: add errs res.value
            ]
          ] [
            if [is-path? spec] [
              if [eq (type-of v) spec] [ out[k]: v ] [
                errs: add errs #[ #{ field: k, error: i"expected type '{type-name-from-type spec}', got '{value-type-name v}'" } ]
              ]
            ] [
              out[k]: v
            ]
          ]
        ]
      ]
    ] [
      if [is-default-marker? spec] [
        out[k]: spec["value"]
      ] [
        if [is-optional-marker? spec] [
          none
        ] [
          errs: add errs #[ #{ field: k, error: "field is required" } ]
        ]
      ]
    ]
  ]
  if [eq (len errs) 0] [
    response ok out
  ] [
    response err errs
  ]
]

-- The canonical way to create a new instance of an object.
-- This is a generic function that dispatches on arity.
create: fn {} [ scope #{} ]
create: fn {prototype} [ scope #{} |inherit prototype ]
create: fn {prototype, config-block} [
    (scope #{} |inherit prototype) |with config-block
]


-- --- Control Flow ---

-- Extract a single, untyped parameter name from a sig like {x}.
-- Errors if the sig has types/keywords, a rest parameter, a return annotation,
-- or does not have exactly one positional parameter. Returns the name string.
extract-simple-param: fn {vars} [
    probe: do [
        #{
            pos: vars.positional,
            kws: vars.keywords,
            rest: vars.rest,
            ret: vars.return_annotation
        }
    ]
    if [probe.outcome.status = err] [
        respond err "extract-simple-param expects a sig literal (e.g., {x})"
    ]
    info: probe.outcome.value
    if [info.ret != none] [
        respond err "extract-simple-param: return annotation is not allowed"
    ]
    if [info.rest] [
        respond err "extract-simple-param: rest parameter is not allowed"
    ]
    if [(len info.kws) > 0] [
        respond err "extract-simple-param: typed parameters/keywords are not allowed"
    ]
    if [(len info.pos) != 1] [
        respond err "extract-simple-param: expected exactly one positional parameter"
    ]
    info.pos[0]
]

-- Provides a conditional branch without a required 'else' block.
when: fn {condition, then-block} [
    if [run-with condition current-scope] then-block []
]

-- Provides an infinite loop. This is an alias for `while [true] [...]`.
loop: fn {body-block} [
    while [true] body-block
]

-- A simple counted loop: for {i} <start> <end> [body]
-- - The signature must be a single, untyped positional (e.g., {i}); otherwise errors.
-- - Iterates from start toward end by +1 or -1 depending on ordering.
-- - The loop is end-exclusive (runs while i < end when counting up, or i > end when counting down).
-- - The loop variable is bound in the current scope each iteration.
-- - Returns none (use while to collect/return a value if needed).
for: fn {vars, start, end, body-block} [
    var-name: extract-simple-param vars
    -- Capture the caller’s lexical scope (parent of this function call scope)
    for-scope: current-scope
    for-scope: for-scope["meta"]["parent"]
    step: if [start <= end] [1] [-1]
    i: start
    while [if [step > 0] [i < end] [i > end]] [
        -- On each iteration, set the loop variable in the current scope.
        for-scope[var-name]: i
        run-with body-block for-scope
        i: i + step
    ]
    none
]

-- A multi-branch conditional, like a switch statement. It takes a list of
-- [condition-block, result-expression] pairs. It executes the first
-- condition-block that returns a truthy value, and then returns the
-- corresponding result-expression.
-- Example:
--   x: 5
--   cond #[
--       #[ [x < 5], "less" ],
--       #[ [x > 5], "greater" ],
--       #[ [true], "equal" ]
--   ]  -- returns "equal"
cond: fn {clauses} [
    foreach {clause} clauses [
        [condition-block, result-expr]: clause

        -- Execute the condition block. If it's truthy...
        if [run-with condition-block current-scope] [
            -- ...return the associated result.
            -- If the result expression is a code block, run it. Otherwise,
            -- it's a literal, so return it directly.
            if [is-code? result-expr] [
                return (run-with result-expr current-scope)
            ] [
                return result-expr
            ]
        ]
    ]
    -- If no conditions match, return none.
    return none
]

-- Executes a block of code or merges a mapping within the context of a given
-- object, then returns the object. Ideal for fluent configuration.
-- Example (code block): obj |with [ name: "new" ]
-- Example (mapping):    obj |with #{ hp: 100 }
with: fn {obj: `scope`, config: `code`} [
    -- Run the code block in the context of the object
    run-with config obj
    return obj
]
with: fn {obj: `scope`, config: `mapping`} [
    -- Merge key-value pairs from the mapping into the object
    foreach {k, v} (items config) [
        obj[k]: v
    ]
    return obj
]

