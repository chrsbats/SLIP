{--
    SLIP Core Library v1.0

    This library provides a set of common, high-level utilities
    written in pure SLIP. It is loaded into the global scope.
    Note: this file is loaded directly into the root scope, so all
    definitions are global.
--}

-- --- Operator and Alias Definitions ---
-- Note: The core functions (add, sub, etc.) are host primitives.
-- These bindings make them available as infix operators.
+: |core-add
-: |core-sub
*: |core-mul
/: |core-div
**: |core-pow
=: |core-eq
!=: |core-neq
>: |core-gt
>=: |core-gte
<: |core-lt
<=: |core-lte
and: |logical-and
or: |logical-or

-- Common aliases for response statuses
ok:        `ok`
err:       `err`
not-found: `not-found`
invalid:   `invalid`

-- (No type aliases; refer to types via backticked path literals like `string`, `number`, `list`)

-- Common aliases
print: fn {msg} [ emit "stdout" msg ]
stderr: fn {msg} [ emit "stderr" msg ]

-- --- Type Utilities ---
-- Note: `type-of` is a host primitive.
is-number?:  fn {x} [ logical-or (eq (type-of x) `int`) (eq (type-of x) `float`) ]
is-string?:  fn {x} [ logical-or (eq (type-of x) `string`) (eq (type-of x) `i-string`) ]
is-list?:    fn {x} [ eq (type-of x) `list` ]
is-dict?:    fn {x} [ eq (type-of x) `dict` ]
is-scope?:   fn {x} [ eq (type-of x) `scope` ]
is-path?:    fn {x} [ eq (type-of x) `path` ]
is-fn?:      fn {x} [ eq (type-of x) `function` ]
is-code?:    fn {x} [ eq (type-of x) `code` ]
is-boolean?: fn {x} [ eq (type-of x) `boolean` ]
is-none?:    fn {x} [ eq (type-of x) `none` ]

-- --- String and Path Utilities ---
-- Provide a generic 'join' with typed methods for strings and paths.
-- String variant: join a list of strings with a separator.
join: fn {xs: `list`, sep: `string`} [
    (call str-join #[ xs, sep ])
]

-- Path variant: join path segments/values into a single path literal.
join: fn {first: `path`, rest...} [
    args: add #[ first ] rest
    (call join-paths args)
]


-- String variant (delegates to primitive)
replace: fn {s: `string`, old: `string`, new: `string`} [
  str-replace s old new
]

-- Unions: ordered sequence-like and mapping-like
ordered: { code, list, dict, scope }
mapping: { dict, scope }
number: { int, float }

-- List-like variant: replace items equal to old[0] with new[0] (works for Code and List)
replace: fn {src: `ordered`, old: `ordered`, new: `ordered`} [
  out: clone src
  i: 0
  while [i < (len out)] [
    if [eq out[i] old[0]] [
      out[i]: new[0]
    ]
    i: i + 1
  ]
  out
]

-- --- List & Sequence Utilities ---

-- Reverses a list by iterating through it and prepending
-- each item to a new list.
reverse: fn {data-list: `ordered`} [
    result: #[]
    -- For each item in the original list (from start to end)...
    foreach item data-list [
        -- ...prepend it to the front of our result list.
        result: add #[ item ] result
    ]
    return result
]

-- Applies a function to each item in a list and returns a new
-- list containing the results.
map: fn {func, data-list: `ordered`} [
    results: #[]
    foreach item data-list [
        results: add results #[ (func item) ]
    ]
    return results
]

-- Filters a list, returning a new list containing only the items
-- for which the predicate function returns a truthy value.
filter: fn {predicate, data-list: `ordered`} [
    results: #[]
    foreach item data-list [
        if [predicate item] [
            results: add results #[ item ]
        ]
    ]
    return results
]

-- Reduces a list to a single value by applying a function cumulatively.
reduce: fn {reducer, accumulator, data-list: `ordered`} [
    foreach item data-list [
        accumulator: reducer accumulator item
    ]
    return accumulator
]

-- Combines two lists into a list of pairs. The resulting list's
-- length is determined by the shorter of the two input lists.
zip: fn {list-a: `ordered`, list-b: `ordered`} [
    results: #[]
    limit: if [(len list-a) < (len list-b)] [len list-a] [len list-b]
    i: 0
    while [i < limit] [
        results: add results #[ #[ list-a[i], list-b[i] ] ]
        i: i + 1
    ]
    return results
]

-- --- Function Utilities ---

-- Creates a new function that, when called, will invoke the original
-- function with the pre-supplied arguments, followed by any new arguments.
partial: fn {func, partial-args...} [
    return (fn {new-args...} [
        -- `add` creates a new list by concatenating the pre-supplied
        -- arguments with any new arguments.
        all-args: add partial-args new-args
        return (call func all-args)
    ])
]

-- Composes functions, returning a new function that applies them from
-- right to left. (compose f g h)(x) is equivalent to f(g(h(x))).
compose: fn {funcs...} [
    return (fn {initial-arg} [
        return (reduce (fn {acc, f} [ call f #[ acc ] ]) initial-arg (reverse funcs))
    ])
]

-- --- Object Model Utilities ---

-- The base object for all validation schemas.
Schema: scope #{}

-- The canonical way to create a validation schema.
schema: fn {config} [
    (scope config) |inherit Schema
]

-- Checks if an object inherits from a given prototype.
is-a?: fn {obj, proto} [
    -- We can only check scopes.
    if [not (is-scope? obj)] [
        return false
    ]
    current: obj
    while [current] [
        if [eq current proto] [
            return true
        ]
        -- Walk up the prototype chain.
        current: current.meta.parent
    ]
    return false
]

-- Checks if an object is a schema.
is-schema?: fn {obj} [
    is-a? obj Schema
]

-- The canonical way to create a new instance of an object.
-- This is a generic function that dispatches on arity.
create: fn {} [ scope #{} ]
create: fn {prototype} [ scope #{} |inherit prototype ]
create: fn {prototype, config-block} [
    (scope #{} |inherit prototype) |with config-block
]


-- --- Control Flow ---

-- Provides a conditional branch without a required 'else' block.
when: fn {condition, then-block} [
    if [run condition] then-block []
]

-- Provides an infinite loop. This is an alias for `while [true] [...]`.
loop: fn {body-block} [
    while [true] body-block
]

-- A multi-branch conditional, like a switch statement. It takes a list of
-- [condition-block, result-expression] pairs. It executes the first
-- condition-block that returns a truthy value, and then returns the
-- corresponding result-expression.
-- Example:
--   x: 5
--   cond #[
--       #[ [x < 5], "less" ],
--       #[ [x > 5], "greater" ],
--       #[ [true], "equal" ]
--   ]  -- returns "equal"
cond: fn {clauses} [
    foreach clause clauses [
        [condition-block, result-expr]: clause

        -- Execute the condition block. If it's truthy...
        if [run condition-block] [
            -- ...return the associated result.
            -- If the result expression is a code block, run it. Otherwise,
            -- it's a literal, so return it directly.
            if [is-code? result-expr] [
                return (run result-expr)
            ] [
                return result-expr
            ]
        ]
    ]
    -- If no conditions match, return none.
    return none
]

-- Executes a block of code within the context of a given object,
-- then returns the object. Ideal for fluent configuration.
-- Example: obj |with [ name: "new" ]
with: fn {obj, block} [
    -- Run the code block in the context of the object
    run-with block obj

    -- Return the original, now-modified object
    return obj
]
