{--
    SLIP Core Library v1.0

    This library provides a set of common, high-level utilities
    written in pure SLIP. It is loaded into the global scope.
    Note: this file is loaded directly into the root scope, so all
    definitions are global.
--}

-- --- Operator and Alias Definitions ---
-- Note: The core functions (add, sub, etc.) are host primitives.
-- These bindings make them available as infix operators.
+: |add
-: |sub
*: |mul
/: |div
**: |pow
=: |eq
!=: |neq
>: |gt
>=: |gte
<: |lt
<=: |lte
and: |logical-and
or: |logical-or

-- Common aliases for response statuses
ok:        `ok`
err:       `err`
not-found: `not-found`
invalid:   `invalid`

-- Common aliases
print: fn {msg} [ emit "stdout" msg ]
stderr: fn {msg} [ emit "stderr" msg ]

-- --- Type Utilities ---
-- Note: `type-of` is a host primitive.
is-number?:  fn {x} [ logical-or (eq (type-of x) `int`) (eq (type-of x) `float`) ]
is-string?:  fn {x} [ logical-or (eq (type-of x) `string`) (eq (type-of x) `i-string`) ]
is-list?:    fn {x} [ eq (type-of x) `list` ]
is-dict?:    fn {x} [ eq (type-of x) `dict` ]
is-scope?:   fn {x} [ eq (type-of x) `scope` ]
is-path?:    fn {x} [ eq (type-of x) `path` ]
is-fn?:      fn {x} [ eq (type-of x) `function` ]
is-code?:    fn {x} [ eq (type-of x) `code` ]
is-boolean?: fn {x} [ eq (type-of x) `boolean` ]
is-none?:    fn {x} [ eq (type-of x) `none` ]

-- --- List & Sequence Utilities ---

-- Reverses a list by iterating through it and prepending
-- each item to a new list.
reverse: fn {data-list} [
    result: #[]
    -- For each item in the original list (from start to end)...
    foreach item data-list [
        -- ...prepend it to the front of our result list.
        result: add #[ item ] result
    ]
    return result
]

-- Applies a function to each item in a list and returns a new
-- list containing the results.
map: fn {func, data-list} [
    results: #[]
    foreach item data-list [
        results: add results #[ (func item) ]
    ]
    return results
]

-- Filters a list, returning a new list containing only the items
-- for which the predicate function returns a truthy value.
filter: fn {predicate, data-list} [
    results: #[]
    foreach item data-list [
        if [predicate item] [
            results: add results #[ item ]
        ]
    ]
    return results
]

-- Reduces a list to a single value by applying a function cumulatively.
reduce: fn {reducer, accumulator, data-list} [
    foreach item data-list [
        accumulator: reducer accumulator item
    ]
    return accumulator
]

-- Combines two lists into a list of pairs. The resulting list's
-- length is determined by the shorter of the two input lists.
zip: fn {list-a, list-b} [
    results: #[]
    limit: if [len list-a < len list-b] [len list-a] [len list-b]
    i: 0
    while [i < limit] [
        results: add results #[ #[ list-a[i], list-b[i] ] ]
        i: i + 1
    ]
    return results
]

-- --- Function Utilities ---

-- Creates a new function that, when called, will invoke the original
-- function with the pre-supplied arguments, followed by any new arguments.
partial: fn {func, partial-args...} [
    return fn {new-args...} [
        -- `add` creates a new list by concatenating the pre-supplied
        -- arguments with any new arguments.
        all-args: add partial-args new-args
        return call func all-args
    ]
]

-- Composes functions, returning a new function that applies them from
-- right to left. (compose f g h)(x) is equivalent to f(g(h(x))).
compose: fn {funcs...} [
    return fn {initial-arg} [
        result: initial-arg
        foreach func (reverse funcs) [
            result: func result
        ]
        return result
    ]
]

-- --- Object Model Utilities ---

-- The base object for all validation schemas.
Schema: scope #{}

-- The canonical way to create a validation schema.
schema: fn {config} [
    (scope config) |inherit Schema
]

-- Checks if an object inherits from a given prototype.
is-a?: fn {obj, proto} [
    -- We can only check scopes.
    if [not (is-scope? obj)] [
        return false
    ]
    current: obj
    while [current] [
        if [eq current proto] [
            return true
        ]
        -- Walk up the prototype chain.
        current: current.meta.parent
    ]
    return false
]

-- Checks if an object is a schema.
is-schema?: fn {obj} [
    is-a? obj Schema
]

-- The canonical way to create a new instance of an object.
-- This is a generic function that dispatches on arity.
create: fn {} [ scope #{} ]
create: fn {prototype} [ scope #{} |inherit prototype ]
create: fn {prototype, config-block} [
    (scope #{} |inherit prototype) |with config-block
]

-- --- Control Flow ---

-- Provides a conditional branch without a required 'else' block.
when: fn {condition, then-block} [
    if [run condition] then-block []
]

-- Provides an infinite loop. This is an alias for `while [true] [...]`.
loop: fn {body-block} [
    while [true] body-block
]

-- A multi-branch conditional, like a switch statement. It takes a list of
-- [condition-block, result-expression] pairs. It executes the first
-- condition-block that returns a truthy value, and then returns the
-- corresponding result-expression.
-- Example:
--   x: 5
--   cond #[
--       #[ [x < 5], "less" ],
--       #[ [x > 5], "greater" ],
--       #[ [true], "equal" ]
--   ]  -- returns "equal"
cond: fn {clauses} [
    foreach clause clauses [
        [condition-block, result-expr]: clause

        -- Execute the condition block. If it's truthy...
        if [run condition-block] [
            -- ...return the associated result.
            -- If the result expression is a code block, run it. Otherwise,
            -- it's a literal, so return it directly.
            if [is-code? result-expr] [
                return (run result-expr)
            ] [
                return result-expr
            ]
        ]
    ]
    -- If no conditions match, return none.
    return none
]

-- Executes a block of code within the context of a given object,
-- then returns the object. Ideal for fluent configuration.
-- Example: obj |with [ name: "new" ]
with: fn {obj, block} [
    -- Run the code block in the context of the object
    run-with block obj

    -- Return the original, now-modified object
    return obj
]
