# Koine grammar for the SLIP language - Structural Pass

start_rule: program

rules:
  # =================================================================
  # Top Level & Whitespace
  # =================================================================

  program_padding:
    ast: { discard: true }
    zero_or_more:
      choice:
        - { regex: '[ \t]+' }
        - { rule: comment }
        - { rule: NEWLINE }

  program:
    ast: { tag: "code" }
    sequence:
      - { rule: program_padding }
      - { rule: expression_list }
      - { rule: program_padding }
      - { rule: EOI }

  non_empty_expression_list:
    ast: { promote: true }
    sequence: # one or more expressions
      - { rule: line_expression }
      - zero_or_more:
          ast: { promote: true }
          sequence:
            - { rule: expression_separator_plus }
            - { rule: line_expression }
      - optional: { rule: expression_separator_plus }

  expression_list:
    ast: { promote: true }
    choice:
      - { rule: non_empty_expression_list }
      - { rule: empty_list_producer }

  empty_list_producer:
    ast: { promote: true }
    zero_or_more: { regex: "(?!)" } # Always matches an empty list

  expression_separator:
    ast: { discard: true }
    choice:
      - { literal: ";" }
      - { literal: "," }
      - { rule: NEWLINE }

  expression_separator_plus:
    ast: { discard: true }
    sequence:
      - { rule: WS_OPT }
      - one_or_more:
          sequence:
            - { rule: expression_separator }
            - { rule: WS_OPT }

  NEWLINE:
    ast: { discard: true }
    regex: '[\r\n]+'

  EOI:
    ast: { discard: true }
    regex: '\Z'

  line_expression:
    ast: { tag: "expr" }
    choice:
      - { rule: expression_content }
      - { rule: comment }

  expression_content:
    ast: { promote: true }
    sequence:
      - { rule: term }
      - zero_or_more:
          ast: { promote: true }
          choice:
            # Same-line continuation: whitespace followed by any term
            - sequence:
                - { rule: WS_OPT }
                - { rule: term }
            # Line continuation for infix/pipe chains: allow a newline before a piped-path
            - sequence:
                - { rule: WS_OPT_NL }
                - { rule: piped_path }

  WS_OPT: # Optional whitespace (includes comments, no newlines)
    ast: { discard: true }
    zero_or_more:
      choice:
        - { regex: '[ \t]+' }
        - { rule: comment }

  WS_OPT_NL: # Optional whitespace including comments and newlines
    ast: { discard: true }
    zero_or_more:
      choice:
        - { regex: '[ \t]+' }
        - { rule: comment }
        - { rule: NEWLINE }

  comment:
    ast: { tag: "comment" }
    choice:
      - { rule: line_comment }
      - { rule: block_comment }

  line_comment:
    ast: { tag: "line-comment", leaf: true }
    regex: '--[^\r\n]*'

  block_comment:
    ast: { tag: "block-comment" }
    sequence:
      - { literal: "{--", ast: { discard: true } }
      - zero_or_more:
          choice:
            - { rule: block_comment } # nested comment
            - { regex: '(?:(?!\{--|--})[\s\S])+' }
      - { literal: "--}", ast: { discard: true } }

  # =================================================================
  # Terms (High-level structural units)
  # =================================================================

  term:
    ast: { promote: true }
    # Order is crucial: match containers and literals before the generic path rules.
    choice:
      - { rule: typed_list_literal }
      - { rule: list_literal }
      - { rule: dict_literal }
      - { rule: sig_literal }
      - { rule: string_literal }
      - { rule: number_literal }
      - { rule: boolean_literal }
      - { rule: none_literal }
      - { rule: path_literal }
      # Path-like terms must be ordered by specificity: set/del before get.
      - { rule: set_path }
      - { rule: post_path }
      # Code block and group must be tried *after* set_path to allow multi_set_path and dynamic assignment to match first.
      - { rule: code_block }
      - { rule: group }
      - { rule: piped_path }
      - { rule: del_path }
      - { rule: get_path }

  get_path:
    ast: { promote: true }
    subgrammar:
      file: "slip_path.yaml"
      rule: "embedded_get_path"
      placeholder:
        {
          ast: { tag: "get-path", leaf: true },
          regex: '[^ \t\r\n;,\(\)\[\]\{\}\''"`|~]+',
        }

  del_path:
    ast: { promote: true }
    subgrammar:
      file: "slip_path.yaml"
      rule: "embedded_del_path"
      placeholder:
        {
          ast: { tag: "del-path", leaf: true },
          regex: '~[^ \t\r\n;,\{\}\''"`]+',
        }

  piped_path:
    ast: { promote: true }
    subgrammar:
      file: "slip_path.yaml"
      rule: "embedded_piped_path"
      placeholder:
        {
          ast: { tag: "piped-path", leaf: true },
          regex: '\|[^ \t\r\n;,\(\)\[\]\{\}\''"`]+',
        }

  set_path:
    ast: { promote: true }
    subgrammar:
      file: "slip_path.yaml"
      rule: "embedded_set_path"
      placeholder:
        {
          ast: { tag: "set-path", leaf: true },
          # This regex matches URL tokens (including ://), bracketed queries, and non-separators,
          # optionally followed by a metadata block, and finally a colon that is not the scheme colon.
          regex: '(?:(?:://)|\[.*?\]|[^ \t\r\n;:])+(?:#\([^)]*\))?:(?!//)',
        }

  post_path:
    ast: { promote: true }
    subgrammar:
      file: "slip_path.yaml"
      rule: "embedded_post_path"
      placeholder:
        {
          ast: { tag: "post-path", leaf: true },
          # match “...<-” end marker; allow :// inside token; avoid separators and '<' inside token
          regex: '(?:(?:://)|\[.*?\]|[^ \t\r\n;,<>\(\)\[\]\{\}:])+(?:#\([^)]*\))?<-',
        }

  # =================================================================
  # Literals
  # =================================================================

  number_literal:
    ast: { tag: "number", leaf: true, type: "number" }
    regex: '-?\d+(\.\d+)?'

  string_literal:
    ast: { promote: true }
    choice:
      - { rule: raw_string }
      - { rule: interpolated_string }

  raw_string:
    ast: { promote: true }
    sequence:
      - { literal: "'", ast: { discard: true } }
      - { rule: raw_string_content }
      - { literal: "'", ast: { discard: true } }
  raw_string_content:
    ast: { tag: "string", leaf: true }
    regex: '([^\''\\]|\\.)*'

  interpolated_string:
    ast: { promote: true }
    sequence:
      - { literal: '"', ast: { discard: true } }
      - { rule: interpolated_string_content }
      - { literal: '"', ast: { discard: true } }
  interpolated_string_content:
    ast: { tag: "i-string", leaf: true }
    regex: '([^"\\]|\\.)*'

  boolean_literal:
    ast: { tag: "boolean", leaf: true, type: "bool" }
    choice:
      - { literal: "true" }
      - { literal: "false" }

  none_literal:
    ast: { tag: "null", leaf: true, type: "null" }
    literal: "none"

  path_literal:
    ast: { tag: "path-literal" }
    sequence:
      - { literal: "`", ast: { discard: true } }
      - subgrammar:
          file: "slip_path.yaml"
          rule: "any_embedded_path"
          placeholder: { ast: { tag: "path-placeholder", leaf: true }, regex: "[^`]*" }
      - { literal: "`", ast: { discard: true } }

  # =================================================================
  # Grouping & Container Literals
  # =================================================================

  # These rules are recursive and define the overall structure.
  # Their contents are parsed using `expression_list`.

  group:
    ast: { tag: "group" }
    sequence:
      - { literal: "(", ast: { discard: true } }
      - { rule: WS_OPT_NL }
      - { rule: expression_list }
      - { rule: WS_OPT_NL }
      - { literal: ")", ast: { discard: true } }

  code_block:
    ast: { tag: "code" }
    sequence:
      - { literal: "[", ast: { discard: true } }
      - { rule: WS_OPT_NL }
      - { rule: expression_list }
      - { rule: WS_OPT_NL }
      - { literal: "]", ast: { discard: true } }

  typed_list_literal:
    ast: { tag: "typed-list" }
    sequence:
      - { rule: typed_list_type, ast: { name: "t" } }
      - { literal: "#[", ast: { discard: true } }
      - { rule: WS_OPT_NL }
      - { rule: expression_list, ast: { name: "items" } }
      - { rule: WS_OPT_NL }
      - { literal: "]", ast: { discard: true } }

  typed_list_type:
    ast: { tag: "typed-name", leaf: true }
    regex: '(?:i8|i16|i32|i64|u8|u16|u32|u64|f32|f64|b1)'

  list_literal:
    ast: { tag: "list" }
    sequence:
      - { literal: "#[", ast: { discard: true } }
      - { rule: WS_OPT_NL }
      - { rule: expression_list }
      - { rule: WS_OPT_NL }
      - { literal: "]", ast: { discard: true } }

  dict_literal:
    ast: { tag: "dict" }
    sequence:
      - { literal: "#{", ast: { discard: true } }
      - { rule: WS_OPT_NL }
      - { rule: expression_list }
      - { rule: WS_OPT_NL }
      - { literal: "}", ast: { discard: true } }

  sig_literal:
    ast: { promote: true }
    sequence:
      - { literal: "{", ast: { discard: true } }
      - subgrammar:
          file: "slip_sig.yaml"
          rule: "sig"
          placeholder:
            ast: { tag: "sig" }
            sequence:
              - { rule: WS_OPT }
              - { rule: expression_list, ast: { promote: true } }
              - { rule: WS_OPT }
      - { literal: "}", ast: { discard: true } }
